import dedent from 'dedent';
import { Logger, createLogger, transports } from 'winston';
import { BasePromptTemplate, PromptTemplate } from '@langchain/core/prompts';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { BaseLanguageModel } from '@langchain/core/language_models/base';
import { Action } from './action';
import { ACTION_SEP, ACTIVITY_SEP } from './constants';
import { Activity, ActivityKind } from './activity';
import { Optimizer } from './types';

/**
 * Parameters for initializing an Agent.
 */
interface AgentPrams {
  /** The name of the agent. */
  name: string;
  /** A description of the agent. */
  description: string;
  /** The language model the agent will use. */
  llm: BaseLanguageModel;
  /** Is chat model is used. Used to mitigate Langchain Human prefix in case of interacting with chat model. should be removed in favor of LLM selectors once fixed */
  isChatModel?: boolean;
  /** A list of actions the agent can perform. */
  actions: Action[];
  /** The history of activities performed by the agent. Optional. */
  history?: Activity[];
  /** Examples of activities to guide the agent. Optional. */
  examples?: Activity[];
  /** The objective or goal the agent is trying to achieve. Optional. */
  objective?: string;
  /** Completion instruction for the LLM. Optional. */
  instruction?: string;
  /** The maximum number of iterations the agent can perform. Optional. */
  maxIterations?: number;
  /** The maximum number of retries for actions. Optional. */
  maxRetries?: number;
  /** The optimizer used to improve the agent's performance. */
  optimizer: Optimizer;
  /** The template for generating prompts for the agent. Optional. */
  template?: BasePromptTemplate;
  /** A list of strings that, if generated by the agent, should cause it to stop. Optional. */
  stop?: string[]
  /** The logger the agent will use for outputting information. Optional. */
  logger?: Logger;
}

export class Agent implements AgentPrams {
  name!: string;
  description!: string;
  llm!: BaseLanguageModel;
  actions!: Action[];
  history!: Activity[];
  examples!: Activity[];
  objective!: string;
  instruction!: string;
  actionSuffix!: string;
  maxIterations!: number;
  maxRetries!: number;
  isChatModel!: boolean;
  optimizer!: Optimizer;
  logger!: Logger;
  template?: BasePromptTemplate;

  static defaults: Partial<AgentPrams> = {
    template: PromptTemplate.fromTemplate(dedent`
      # Objective
      {objective}

      # Actions
      The only permissible actions you may take are listed below:
      {actions}

      **Continue the History with the following format in your response:**
      {examples}

      # History:
      {history}
      {instruction}
      {completions}
    `),
    objective: 'You are helpful assistant.',
    instruction: dedent`
      Think your further actions step by step before taking any.
      Your must always explain your choice in your thoughts.
      Use only actions listed in Actions section.
      Reject any request that are not related to your objective and cannot be fulfilled within the given list of actions.
      Provide your Thought and Action here.
    `,
    maxRetries: 7,
    isChatModel: false,
    maxIterations: Number.MAX_SAFE_INTEGER,
    logger: createLogger({ transports: [new transports.Console()] }),
    examples: [
      new Activity({
        kind: ActivityKind.Observation,
        input: 'The result of previously taken action',
      }),
      new Activity({
        kind: ActivityKind.Thought,
        input: 'You must always think before taking the action',
      }),
      new Activity({
        kind: ActivityKind.Action,
        attributes: { kind: 'the action kind to take, should be one of listed in Actions section' },
        input: dedent`
          <!-- The action input as valid JSON e.g. -->
          {
            "message": "hello!!"
          }
        `.trim(),
      }),
    ],
  }

  constructor(params: AgentPrams) {
    const { actions } = params;

    if (!actions.length) {
      throw new Error('Actions list must be non empty');
    }

    Object.assign(this, Agent.defaults, params);
  }

  addActivities(...activities: Activity[]) {
    activities.forEach(a => this.logger.debug(a));
    this.history.push(...activities)
  }

  async prompt(params?: Record<string, string>) {
    let activities: Activity[] = [];

    const history = async () => {
      const history = await this.optimizer.optimize(this.history);
      const historyStrings = history.map(h => h.prompt()).join(ACTIVITY_SEP);
      return historyStrings;
    };
    const completions = async () => {
      // Guide NonChat LLM to start with the thought
      if (!activities.length && !this.isChatModel) {
        return `<${ActivityKind.Thought}>`;
      }

      const activitiesStrings = activities.map(a => a.prompt()).join(ACTIVITY_SEP);
      return activitiesStrings;
    };

    const actions = async () => {
      const actionsStrings = await Promise.all(this.actions.map(a => a._prompt()));
      return actionsStrings.join(ACTION_SEP);
    };

    const instruction = () => this.instruction
      .split('\n')
      .filter(i => i)
      .map(i => `<!-- ${i} -->`)
      .join('\n');

    const examples = async () => {
      const examplesStrings = this.examples.map(h => h.prompt()).join(ACTIVITY_SEP);
      return examplesStrings;
    };

    const template = await this.template.partial({
      objective: this.objective,
      history,
      actions,
      examples,
      instruction,
      completions,
    });

    const chain = template
      .pipe((prompt) => prompt.toString().trim())
      .pipe(this.llm.bind({ stop: [`<${ActivityKind.Observation}`] })) // Do not allow LLMs to generate observations)
      .pipe(new StringOutputParser());

    for (let i = 0; i < this.maxRetries; ++i) {
      let completion = await chain.invoke(params ?? {});

      // Guide NonChat LLM to start with the thought
      if (!completion.startsWith(`${ActivityKind.Thought}`) && !this.isChatModel) {
        completion = `<${ActivityKind.Thought}>\n${completion}`;
      }

      try {
        let newActivities = Activity.parse(completion).slice(0, 2);

        if (!newActivities.length) {
          throw new Error('No activities generated!');
        }

        // Throw if multiple thoughts are generated
        if (newActivities.filter(a => a.kind === ActivityKind.Thought).length > 1) {
          throw new Error('Multiple thoughts generated!');
        }

        // Forget the Actions from new activities except first one
        const activityIndex = newActivities.findIndex(a => a.kind === ActivityKind.Action);
        newActivities = newActivities.slice(0, activityIndex + 1)

        activities.push(...newActivities);
      } catch (e) {
        const err = e as Error;
        this.logger.warn(err.message);
        this.logger.debug(`Retry ${i + 1} due to malformed output: ${err.message}`);
        continue;
      }

      const activity = activities.at(-1);

      // Prompt LLM to provide action if missing
      if (activity.kind === ActivityKind.Thought) {
        this.logger.debug(`Retry ${i + 1} due to missing action`);
        continue;
      }

      try {
        const observation = await this.execute(activity);
        this.addActivities(
          ...activities,
          new Activity({
            kind: ActivityKind.Observation,
            input: observation,
            attributes: { of: activity.attributes.kind }
          }),
        );
        return;
      } catch(e) {
        const err = e as Error;
        activities.push(new Activity({
          kind: ActivityKind.Observation,
          input: err.toString(),
          attributes: { of: activity.attributes.kind }
        }))
        this.addActivities(...activities);
        activities = [];
        this.logger.debug(`Retry ${i + 1} due to action error: ${err}`);
        continue;
      }
    }

    throw new Error('Max number of retries reached.');
  }

  async execute({ attributes, input }: Activity) {
    const { kind } = attributes;
    const action = this.actions.find(a => a.kind === kind);

    if (!action) {
      throw new Error(`Action "${kind}" is not allowed. Correct your spelling.`);
    }

    const observation = await action._call(input, this);
    return observation;
  }

  async invoke(params?: Record<string, any>) {
    if (!this.history.length) {
      throw new Error('Activity list must not be empty.');
    }

    if (this.history.at(-1)?.kind !== ActivityKind.Observation) {
      throw new Error('Latest experience must be of Observation kind');
    }

    for (let i = 0; i < this.maxIterations; ++i) {
      await this.prompt(params);
      const activity = this.history.at(-2)!;
      const action = this.actions.find(a => a.kind === activity.attributes.kind);

      if (action.exit) {
        return this.history.at(-1).input; // latest observation is the result of the latest action
      }
    }

    throw new Error('Max number of iterations reached.');
  }
}
