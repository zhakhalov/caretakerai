import dedent from 'dedent';
import { Logger, createLogger, transports } from 'winston';
import { BasePromptTemplate, PromptTemplate } from 'langchain/prompts';
import { RunnableSequence } from 'langchain/schema/runnable';
import { StringOutputParser } from 'langchain/schema/output_parser';
import { Action } from './action';
import { ACTION_SEP, ACTIVITY_SEP } from './constants';
import { Activity, ActivityKind } from './activity';
import { Optimizer } from './types';
import { BaseLLM } from 'langchain/dist/llms/base';

/**
 * Parameters for initializing an Agent.
 */
interface AgentPrams {
  /** The name of the agent. */
  name: string;
  /** A description of the agent. */
  description: string;
  /** The language model the agent will use. */
  llm: BaseLLM;
  /** A list of actions the agent can perform. */
  actions: Action[];
  /** The history of activities performed by the agent. Optional. */
  history?: Activity[];
  /** Examples of activities to guide the agent. Optional. */
  examples?: Activity[];
  /** Constraints that the agent must adhere to. Optional. */
  constrains?: string[];
  /** The objective or goal the agent is trying to achieve. Optional. */
  objective?: string;
  /** Suffix to append to thoughts in the agent's output. Optional. */
  thoughtSuffix?: string;
  /** Suffix to append to actions in the agent's output. Optional. */
  actionSuffix?: string;
  /** The maximum number of iterations the agent can perform. Optional. */
  maxIterations?: number;
  /** The maximum number of retries for actions. Optional. */
  maxRetries?: number;
  /** The optimizer used to improve the agent's performance. */
  optimizer: Optimizer;
  /** The template for generating prompts for the agent. Optional. */
  template?: BasePromptTemplate;
  /** A list of strings that, if generated by the agent, should cause it to stop. Optional. */
  stop?: string[]
  /** The logger the agent will use for outputting information. Optional. */
  logger?: Logger;
}

export class Agent implements AgentPrams {
  name!: string;
  description!: string;
  llm!: BaseLLM;
  actions!: Action[];
  history!: Activity[];
  examples!: Activity[];
  constrains!: string[];
  objective!: string;
  thoughtSuffix!: string;
  actionSuffix!: string;
  maxIterations!: number;
  maxRetries!: number;
  optimizer!: Optimizer;
  logger!: Logger;
  template?: BasePromptTemplate;

  static defaults: Partial<AgentPrams> = {
    template: PromptTemplate.fromTemplate(dedent`
      # Objective
      {objective}

      # Constraints
      {constraints}

      # Actions
      The only permissible actions you may take are listed below:
      {actions}

      **Continue the History with the following format in your response:**
      {examples}

      # History:
      {history}
      {suffix}
    `.trim()),
    objective: 'You are helpful assistant.',
    thoughtSuffix: '<!-- Provide thought and action here -->',
    actionSuffix: '<!-- Provide action here -->',
    maxRetries: 7,
    maxIterations: Number.MAX_SAFE_INTEGER,
    logger: createLogger({ transports: [new transports.Console()] }),
    examples: [
      new Activity({
        kind: ActivityKind.Observation,
        input: 'The result of previously taken action',
      }),
      new Activity({
        kind: ActivityKind.Thought,
        input: 'You must always think before taking the action',
      }),
      new Activity({
        kind: ActivityKind.Action,
        attributes: { kind: 'the action kind to take, should be one of listed in Actions section' },
        input: dedent`
          <!-- The action input as valid JSON e.g. -->
          {
            "message": "hello!!"
          }
        `.trim(),
      }),
    ],
    constrains: [
      'Use only actions listed in Actions section.',
      'Reject any request that are not related to your objective and cannot be fulfilled within the given list of actions.',
    ]
  }

  constructor(params: AgentPrams) {
    const { actions } = params;

    if (!actions.length) {
      throw new Error('Actions list must be non empty');
    }

    Object.assign(this, Agent.defaults, params);
  }

  addActivities(...activities: Activity[]) {
    activities.forEach(a => this.logger.debug(a));
    this.history.push(...activities)
  }

  async prompt(params?: Record<string, string>) {
    let activities: Activity[] = [];

    const history = async () => {
      const history = [...await this.optimizer.optimize([...this.history, ...activities])];
      const historyStrings = history.map(h => h.prompt()).join(ACTIVITY_SEP);
      return historyStrings;
    };

    const actions = async () => {
      const actionsStrings = await Promise.all(this.actions.map(a => a._prompt()));
      return actionsStrings.join(ACTION_SEP);
    };

    const constraints = () => this.constrains.map((c, i) => `${i + 1}. ${c}`).join('\n');

    const examples = async () => {
      const examplesStrings = this.examples.map(h => h.prompt()).join(ACTIVITY_SEP);
      return examplesStrings;
    };

    const suffix = () => ([...this.history, ...activities].at(-1).kind === ActivityKind.Observation
      ? this.thoughtSuffix
      : this.actionSuffix
    );

    const template = await this.template.partial({
      objective: this.objective,
      history,
      actions,
      constraints,
      examples,
      suffix,
    });

    const seq = RunnableSequence.from([
      template,
      this.llm.bind({ stop: [`<${ActivityKind.Observation}>`] }), // Do not allow LLMs to generate observations
      new StringOutputParser(),
    ]);

    for (let i = 0; i < this.maxRetries; ++i) {
      let completion = await seq.invoke(params ?? {});

      this.logger.debug(completion);

      try {
        activities = [...activities, ...Activity.parse(completion)];
        this.logger.debug('Completion activities', activities);
      } catch (e) {
        this.logger.warn(e);
        this.logger.debug(`Retry ${i + 1} due to malformed output`);
        continue;
      }

      const activity = activities.at(-1)

      if (activity.kind === ActivityKind.Thought) {
        this.logger.debug(`Retry ${i + 1} due to missing action`);
        continue;
      }

      if (activity.kind === ActivityKind.Action) {
        try {
          const observation = await this.execute(activity);
          return [...activities, new Activity({ kind: ActivityKind.Observation, input: observation })];
        } catch(e) {
          const err = e as Error;
          activities.push(new Activity({ kind: ActivityKind.Observation, input: err.toString() }))
          this.logger.debug(`Retry ${i + 1} due to action error`);
          continue;
        }
      }
    }

    throw new Error('Max number of retries reached.');
  }

  async execute({ attributes, input }: Activity) {
    const { kind } = attributes;
    const action = this.actions.find(a => a.kind === kind);

    if (!action) {
      throw new Error(`Action "${kind}" is not allowed.`);
    }

    const observation = await action._call(input, this);
    return observation;
  }

  async invoke(params?: Record<string, any>) {
    if (!this.history.length) {
      throw new Error('Activity list must not be empty.');
    }

    if (this.history.at(-1)?.kind !== ActivityKind.Observation) {
      throw new Error('Latest experience must be of Observation kind');
    }

    for (let i = 0; i < this.maxIterations; ++i) {
      const activities = await this.prompt(params);
      this.addActivities(...activities);
      const activity = this.history.at(-2)!;
      const action = this.actions.find(a => a.kind === activity.attributes.kind);

      if (action.exit) {
        return this.history.at(-1).input; // latest observation is the result of the latest action
      }
    }

    throw new Error('Max number of iterations reached.');
  }
}
